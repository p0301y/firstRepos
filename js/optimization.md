## 缓存
1. 基于浏览器头信息的缓存
主要有两种：一种是判断静态资源http头部的Etag和Last-Modified是否修改；还有一种是根据expires过期的时间来判断的，原理一样，两种方法通常结合使用，如果没有修改就会
返回304 not modified
2. 使用app cache
html5提供了App cache来解决静态文件存储的问题，它通过将要缓存的静态文件申明在一个manifest文件清单中，然后要缓存的html里通过manifest
属性关联清单文件即可在下次载入html时优先加载缓存清单中列出的静态文件
3. localStroge存储
localStorage的存储相对cookie而言的确丰富了许多，也扩大了容量。特点：
适合data数据存储，不适合文件存储【localStorage是对象，js操作文件的效率远远低于浏览器直接操作】
4. indexedDB缓存
将数据存储在浏览器的indexedDB中，当网络断开的时候，可以从浏览器读取数据，用来做一些离线应用，而且不需要写特定的sql语句来对数据库进行操作
，他是nosql的数据形式json，这种方式容量足够，存取自由，但是不适合静态文件的存储
[文件参考]{http://jixianqianduan.com/frontend-javascript/2014/06/05/webworker-serviceworker.html}

未来的web应用是可以离线的，所以w3c新推出了service worker
5. service worker
它可以是浏览器提供给用户的一个网上代理，通过fetch拦截用户的所有请求，可以不向服务器发送，并可以将请求转向本地缓存或其他资源文件的加载，无论是数据还是静态文件，然后可以通过javascript的操作
进行增量操作数据，而且同时不阻塞浏览器的渲染过程
webworker现在可以在浏览器做多线程操作，但是比较限制；service worker是在web worker的基础上实现的，可以认为是使用了webworker的技术来处理网络请求、响应等方面的食物

## 前端如何解决跨域问题
- 背景：跨域是由浏览器的同源策略引起的，是指页面请求的接口地址，必须与页面url地址处于同域上（即域名，端口，协议相同）
这是为了防止某域名下的接口被其他域名下的网页非法调用，是浏览器对javascript施加的安全限制
- 目前常用的跨域的解决方法有：
1. jsonp：利用script标签可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数
2. CROS: 服务器设置HTTP响应头中Access-Control-Allow-Origin值，解决跨域限制，目标服务器需要知道哪些地址的请求是可以响应的（说白了就是一种约定）

下面介绍一种前端独立就能解决的跨域方案【代理和反向代理】
- 代理
代理，称为正向代理，是位于客户端与目标服务器端之间的服务器，为了从目标服务器取得内容，客户端向代理发送一个请求并指定目标（目标服务器），然后代理向目标服务器转交请求并获得内容返回给客户端，应用
如翻墙，利用香港的代理服务器
- 反向代理
浏览器正常发送请求，只是浏览器不知道返回的内容是服务器从其他的服务器获取的